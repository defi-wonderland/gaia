# Mock IPFS Client for Testing and Local Development

## Status

Proposed

## Problem

The `hermes-ipfs-cache` service fetches edit content from IPFS. For testing and local development, we need to mock these IPFS network calls while keeping the rest of the system (cache storage, cursor persistence) real.

## Goals

1. Mock IPFS network fetches without mocking the cache itself
2. Return real `grc20.Edit` protos that match mock `EditsPublished` events
3. Support failure injection for resilience testing
4. Enable local development without IPFS infrastructure
5. Follow the same config pattern as `StreamSource` for consistency

## Design

### IpfsSource Config (Similar to StreamSource)

Following the same pattern as `StreamSource`, introduce an `IpfsSource` enum for explicit configuration:

```rust
// hermes-relay/src/ipfs.rs

use ipfs::{IpfsClient, IpfsFetcher};

/// Configuration for the IPFS data source.
///
/// Use this to explicitly choose between mock and live IPFS clients.
#[derive(Debug, Clone)]
pub enum IpfsSource {
    /// Use mock IPFS client with test topology data.
    ///
    /// Returns `grc20.Edit` protos that match the mock `EditsPublished` events
    /// from `StreamSource::Mock`.
    Mock,

    /// Connect to a live IPFS gateway.
    Live {
        /// The IPFS gateway URL (e.g., "https://ipfs.io/ipfs/")
        gateway_url: String,
    },
}

impl IpfsSource {
    /// Create a mock IPFS source with test topology data.
    pub fn mock() -> Self {
        Self::Mock
    }

    /// Create a live IPFS source with the given gateway URL.
    pub fn live(gateway_url: impl Into<String>) -> Self {
        Self::Live {
            gateway_url: gateway_url.into(),
        }
    }

    /// Create the appropriate IpfsFetcher implementation.
    pub fn into_fetcher(self) -> Box<dyn IpfsFetcher> {
        match self {
            Self::Mock => Box::new(MockIpfsClient::from_test_topology()),
            Self::Live { gateway_url } => Box::new(IpfsClient::new(&gateway_url)),
        }
    }
}
```

### IpfsFetcher Trait

Abstract the IPFS client behind a trait so we can swap implementations:

```rust
// ipfs/src/lib.rs

use async_trait::async_trait;
use wire::pb::grc20::Edit;

/// Trait for fetching content from IPFS.
#[async_trait]
pub trait IpfsFetcher: Send + Sync {
    /// Fetch and decode a GRC-20 Edit from IPFS by URI.
    async fn get(&self, uri: &str) -> Result<Edit>;
    
    /// Fetch raw bytes from IPFS by CID.
    async fn get_bytes(&self, cid: &str) -> Result<Vec<u8>>;
}

/// Production IPFS client that fetches from a gateway.
pub struct IpfsClient {
    url: String,
    client: reqwest::Client,
}

#[async_trait]
impl IpfsFetcher for IpfsClient {
    async fn get(&self, uri: &str) -> Result<Edit> {
        let cid = uri.split_once("://").map(|(_, c)| c).unwrap_or("");
        let bytes = self.get_bytes(cid).await?;
        let data = wire::deserialize::deserialize(&bytes)?;
        Ok(data)
    }
    
    async fn get_bytes(&self, cid: &str) -> Result<Vec<u8>> {
        let url = format!("{}{}", self.url, cid);
        let res = self.client.get(&url).send().await?;
        let bytes = res.bytes().await?;
        Ok(bytes.to_vec())
    }
}
```

### MockIpfsClient

The mock client returns pre-configured `grc20.Edit` data that matches the test topology:

```rust
// hermes-relay/src/source/mock_ipfs.rs

use std::collections::HashMap;
use std::sync::RwLock;
use async_trait::async_trait;
use ipfs::{IpfsFetcher, IpfsError, Result};
use wire::pb::grc20;

use super::mock_events;

/// Mock IPFS client that returns pre-configured edit data.
///
/// Returns `grc20.Edit` protos that correspond to mock `EditsPublished` events
/// from the test topology.
pub struct MockIpfsClient {
    /// Map of URI -> serialized Edit bytes
    edits: RwLock<HashMap<String, Vec<u8>>>,
    /// Optional failure mode for testing error handling
    failure_mode: RwLock<IpfsFailureMode>,
}

impl MockIpfsClient {
    pub fn new() -> Self {
        Self {
            edits: RwLock::new(HashMap::new()),
            failure_mode: RwLock::new(IpfsFailureMode::None),
        }
    }
    
    /// Create a mock client pre-populated with edits from the test topology.
    ///
    /// The edits match those generated by `StreamSource::Mock` / 
    /// `mock_events::test_topology::generate()`.
    pub fn from_test_topology() -> Self {
        let client = Self::new();
        
        for action in mock_events::test_topology::generate() {
            if let Some((uri, edit)) = mock_events::extract_edit_content(&action) {
                let bytes = prost::Message::encode_to_vec(&edit);
                client.edits.write().unwrap().insert(uri, bytes);
            }
        }
        
        client
    }
    
    /// Register an edit to be returned for a given URI.
    pub fn register_edit(&self, uri: &str, edit: grc20::Edit) {
        let bytes = prost::Message::encode_to_vec(&edit);
        self.edits.write().unwrap().insert(uri.to_string(), bytes);
    }
    
    /// Set the failure mode for testing error handling.
    pub fn set_failure_mode(&self, mode: IpfsFailureMode) {
        *self.failure_mode.write().unwrap() = mode;
    }
}

impl Default for MockIpfsClient {
    fn default() -> Self {
        Self::new()
    }
}

#[async_trait]
impl IpfsFetcher for MockIpfsClient {
    async fn get(&self, uri: &str) -> Result<grc20::Edit> {
        // Check failure mode first
        self.check_failure_mode(uri)?;
        
        let bytes = self.get_bytes(uri).await?;
        let edit = prost::Message::decode(bytes.as_slice())
            .map_err(|e| IpfsError::DecodeError(e.to_string()))?;
        Ok(edit)
    }
    
    async fn get_bytes(&self, uri: &str) -> Result<Vec<u8>> {
        // Check failure mode first
        self.check_failure_mode(uri)?;
        
        self.edits
            .read()
            .unwrap()
            .get(uri)
            .cloned()
            .ok_or_else(|| IpfsError::NotFound(format!("URI not found in mock: {}", uri)))
    }
}
```

### Failure Injection

The `MockIpfsClient` supports simulating various failure modes for resilience testing:

```rust
// hermes-relay/src/source/mock_ipfs.rs

use std::collections::HashSet;
use std::time::Duration;

/// Failure modes that can be injected into the mock IPFS client.
#[derive(Debug, Clone, Default)]
pub enum IpfsFailureMode {
    /// All fetches succeed (default)
    #[default]
    None,
    /// Specific URIs fail with an error
    FailUris(HashSet<String>),
    /// Random failures with given probability (0.0 - 1.0)
    RandomFailure(f64),
    /// All fetches timeout (hang forever)
    Timeout,
    /// Fetches succeed but return malformed/corrupt data
    CorruptData,
    /// Fetches are delayed by a fixed duration
    Delay(Duration),
}

impl MockIpfsClient {
    fn check_failure_mode(&self, uri: &str) -> Result<()> {
        match &*self.failure_mode.read().unwrap() {
            IpfsFailureMode::None => Ok(()),
            
            IpfsFailureMode::FailUris(uris) => {
                if uris.contains(uri) {
                    Err(IpfsError::NotFound(format!("Simulated failure for: {}", uri)))
                } else {
                    Ok(())
                }
            }
            
            IpfsFailureMode::RandomFailure(probability) => {
                if rand::random::<f64>() < *probability {
                    Err(IpfsError::NetworkError("Simulated random failure".into()))
                } else {
                    Ok(())
                }
            }
            
            IpfsFailureMode::Timeout => {
                // This would need async handling - simplified here
                Err(IpfsError::Timeout)
            }
            
            IpfsFailureMode::CorruptData => {
                Err(IpfsError::DecodeError("Simulated corrupt data".into()))
            }
            
            IpfsFailureMode::Delay(_duration) => {
                // In async context: tokio::time::sleep(*duration).await;
                Ok(())
            }
        }
    }
    
    /// Simulate a network partition - all fetches fail.
    pub fn simulate_network_partition(&self) {
        self.set_failure_mode(IpfsFailureMode::RandomFailure(1.0));
    }
    
    /// Simulate network recovery - fetches succeed again.
    pub fn simulate_network_recovery(&self) {
        self.set_failure_mode(IpfsFailureMode::None);
    }
    
    /// Simulate specific URIs being unavailable.
    pub fn simulate_missing_uris(&self, uris: HashSet<String>) {
        self.set_failure_mode(IpfsFailureMode::FailUris(uris));
    }
}
```

## Usage

### Development / Testing

Use `IpfsSource::mock()` alongside `StreamSource::mock()`:

```rust
use hermes_relay::{Sink, StreamSource, IpfsSource};
use hermes_ipfs_cache::IpfsCacheSink;

#[tokio::main]
async fn main() -> Result<()> {
    let cache = Cache::new(db_pool).await?;
    
    // Both stream and IPFS use mock data
    let ipfs = IpfsSource::mock().into_fetcher();
    let sink = IpfsCacheSink::new(cache, ipfs);
    
    sink.run(StreamSource::mock()).await?;
    
    Ok(())
}
```

### Production

Use `IpfsSource::live()` alongside `StreamSource::live()`:

```rust
use hermes_relay::{Sink, StreamSource, IpfsSource, HermesModule};
use hermes_ipfs_cache::IpfsCacheSink;

#[tokio::main]
async fn main() -> Result<()> {
    let cache = Cache::new(db_pool).await?;
    
    // Both stream and IPFS use live data
    let ipfs = IpfsSource::live(&env::var("IPFS_GATEWAY")?).into_fetcher();
    let sink = IpfsCacheSink::new(cache, ipfs);
    
    let source = StreamSource::live(
        &env::var("SUBSTREAMS_ENDPOINT")?,
        HermesModule::EditsPublished,
        start_block,
        end_block,
    );
    sink.run(source).await?;
    
    Ok(())
}
```

### Unit Testing with Failure Injection

```rust
#[tokio::test]
async fn test_handles_ipfs_failures() {
    let cache = Cache::new_in_memory().await?;
    let ipfs = MockIpfsClient::from_test_topology();
    
    // Simulate specific URIs failing
    ipfs.simulate_missing_uris(hashset!["ipfs://QmBadCid".into()]);
    
    let sink = IpfsCacheSink::new(cache, ipfs);
    sink.run(StreamSource::mock()).await?;
    
    // Verify error handling
}

#[tokio::test]
async fn test_handles_network_partition() {
    let cache = Cache::new_in_memory().await?;
    let ipfs = MockIpfsClient::from_test_topology();
    
    // Simulate network partition
    ipfs.simulate_network_partition();
    
    let sink = IpfsCacheSink::new(cache, ipfs);
    let result = sink.run(StreamSource::mock()).await;
    
    assert!(result.is_err());
    
    // Simulate recovery
    ipfs.simulate_network_recovery();
    sink.run(StreamSource::mock()).await?;
}
```

## Updated IpfsCacheSink

Make `IpfsCacheSink` generic over `IpfsFetcher`:

```rust
// hermes-ipfs-cache/src/lib.rs

use ipfs::IpfsFetcher;
use hermes_relay::{Sink, StreamSource};

/// IPFS cache sink that implements the hermes-relay Sink trait.
///
/// Generic over the IPFS fetcher, allowing injection of mock implementations.
pub struct IpfsCacheSink<F: IpfsFetcher> {
    cache: Cache,
    ipfs: Arc<F>,
}

impl<F: IpfsFetcher + 'static> IpfsCacheSink<F> {
    /// Create a new IPFS cache sink with the given fetcher.
    pub fn new(cache: Cache, ipfs: F) -> Self {
        Self {
            cache,
            ipfs: Arc::new(ipfs),
        }
    }
}

impl<F: IpfsFetcher + 'static> Sink for IpfsCacheSink<F> {
    type Error = IpfsCacheError;
    
    async fn process_block_scoped_data(&self, data: &BlockScopedData) -> Result<(), Self::Error> {
        // Implementation uses self.ipfs which is now generic
    }
}
```

## Data Flow

```
Development/Testing:
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│ StreamSource::  │────▶│ IpfsCacheSink   │────▶│  Cache (real)   │
│     Mock        │     │                 │     │  (PostgreSQL)   │
└─────────────────┘     └────────┬────────┘     └─────────────────┘
                                 │
                        ┌────────▼────────┐
                        │ IpfsSource::    │
                        │     Mock        │
                        │ (MockIpfsClient)│
                        └─────────────────┘

Production:
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│ StreamSource::  │────▶│ IpfsCacheSink   │────▶│  Cache (real)   │
│     Live        │     │                 │     │  (PostgreSQL)   │
└─────────────────┘     └────────┬────────┘     └─────────────────┘
                                 │
                        ┌────────▼────────┐
                        │ IpfsSource::    │
                        │     Live        │
                        │  (IpfsClient)   │
                        └─────────────────┘
```

## File Changes Summary

### New Files

| File | Description |
|------|-------------|
| `hermes-relay/src/ipfs.rs` | `IpfsSource` enum |
| `hermes-relay/src/source/mock_ipfs.rs` | `MockIpfsClient` implementation |

### Modified Files

| File | Changes |
|------|---------|
| `ipfs/src/lib.rs` | Add `IpfsFetcher` trait |
| `hermes-relay/src/lib.rs` | Export `IpfsSource`, `MockIpfsClient` |
| `hermes-ipfs-cache/src/lib.rs` | Make `IpfsCacheSink` generic |
| `hermes-ipfs-cache/src/main.rs` | Use `IpfsSource` config |

## References

- [0001-mock-substream-integration.md](./0001-mock-substream-integration.md) - `StreamSource` pattern
- [0003-hermes-processor-migration.md](./0003-hermes-processor-migration.md) - Service migration plan
- [wire/proto/grc20.proto](../../../wire/proto/grc20.proto) - GRC-20 Edit proto schema
- [hermes-ipfs-cache](../../../hermes-ipfs-cache/) - IPFS cache service
