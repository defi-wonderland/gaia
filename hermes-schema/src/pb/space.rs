// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PersonalSpacePayload {
    #[prost(bytes = "vec", tag = "1")]
    pub owner: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DefaultDaoSpacePayload {
    /// uuids
    #[prost(bytes = "vec", repeated, tag = "1")]
    pub initial_editors: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    /// uuids
    #[prost(bytes = "vec", repeated, tag = "2")]
    pub initial_members: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HermesCreateSpace {
    /// uuid
    #[prost(bytes = "vec", tag = "1")]
    pub space_id: ::prost::alloc::vec::Vec<u8>,
    /// uuid
    #[prost(bytes = "vec", tag = "2")]
    pub topic_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "5")]
    pub meta: ::core::option::Option<super::blockchain_metadata::BlockchainMetadata>,
    #[prost(oneof = "hermes_create_space::Payload", tags = "3, 4")]
    pub payload: ::core::option::Option<hermes_create_space::Payload>,
}
/// Nested message and enum types in `HermesCreateSpace`.
pub mod hermes_create_space {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        #[prost(message, tag = "3")]
        PersonalSpace(super::PersonalSpacePayload),
        /// We could have a generic space payload using a mapping
        /// between string->bytes, where the key is the field and
        /// the bytes are the value. This makes sense as a generic
        /// interface for new spaces, but at that point the producer
        /// already knows the interface for the space, and we should
        /// just encode it in the schema anyway.
        ///
        /// The only time this approach may make sense is if we allow
        /// 3rd-party producer to publish data to our stream, which we
        /// obviously don't want. Or we could consume some sort of registry
        /// or module-based system that knows how to map from the onchain
        /// event into our hermes payload.
        /// UnknownSpacePayload unknown_space = 5;
        #[prost(message, tag = "4")]
        DefaultDaoSpace(super::DefaultDaoSpacePayload),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VerifiedExtension {
    /// uuid of the space receiving verified trust
    #[prost(bytes = "vec", tag = "1")]
    pub target_space_id: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RelatedExtension {
    /// uuid of the space receiving related trust
    #[prost(bytes = "vec", tag = "1")]
    pub target_space_id: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubtopicExtension {
    /// uuid of the topic receiving trust
    #[prost(bytes = "vec", tag = "1")]
    pub target_topic_id: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HermesSpaceTrustExtension {
    /// uuid of the space extending trust
    #[prost(bytes = "vec", tag = "1")]
    pub source_space_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "5")]
    pub meta: ::core::option::Option<super::blockchain_metadata::BlockchainMetadata>,
    #[prost(oneof = "hermes_space_trust_extension::Extension", tags = "2, 3, 4")]
    pub extension: ::core::option::Option<hermes_space_trust_extension::Extension>,
}
/// Nested message and enum types in `HermesSpaceTrustExtension`.
pub mod hermes_space_trust_extension {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Extension {
        #[prost(message, tag = "2")]
        Verified(super::VerifiedExtension),
        #[prost(message, tag = "3")]
        Related(super::RelatedExtension),
        #[prost(message, tag = "4")]
        Subtopic(super::SubtopicExtension),
    }
}
